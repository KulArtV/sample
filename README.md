*Дек - структура данных, которая представляет собой последовательность элементов и позволяет осуществлять добавление/удаление элементов с обоих концов.*
В C++ дек включен в стандартную библиотеку в виде шаблонного класса `std::deque`. Особенностями его реализации являются следующие характеристики: 

* Амортизированная сложность операций `push_front`, `pop_front`, `push_back` и `pop_back` составляет O(1)
* Поддержана возможность обращения к элементам по индексу за O(1)
* Вместимость дека увеличивается динамически по мере необходимости.
* В отличие от вектора (`std::vector`) ссылки и указатели на объекты не инвалидируются.

Особого внимания заслуживает последний пункт. Инвалидация ссылок и указателей довольно распространенная проблема при работе с вектором. Она заключается в следующем. Допустим, мы сохранили ссылку/указатель на один из элементов вектора (`int& ref = v[1];`), а затем проводили некоторые манипуляции над вектором (в самом простом случае - добавляли новые элементы в конец). Изменится ли значение элемента `v[1]`? Естественно, нет - мы добавляли новые элементы, это не должно повлиять на уже существующие объекты. А что произойдет c `ref`? Добавление нового элемента потенциально может вызвать расширение буфера, которое заключается в копировании элементов в новый буфер и **удалении** старого. Таким образом, теперь `ref` ссылается на удаленный участок памяти более не принадлежащий нашей программе ("висячая/битая" ссылка), работа с `ref` потенциально опасна и приводит к UB. Шаблон `std::deque` этой проблемой не обладает и гарантирует валидность всех ссылок и указателей даже после расширения вместимости.

В этой задаче вам нужно реализовать шаблон Deque упрощенный аналог `std::deque`, который обладает всеми вышеуказанными свойствами. Чтобы этого добиться предлагается использовать кольцевой буфер (https://en.wikipedia.org/wiki/Circular_buffer) массивов фиксированной длины (страниц). Под буфером имеется в виду массив указателей на начало каждой из страниц. Элементы последовательно добавляются в конкретную страницу, после того как страница заполнена полностью, начинает заполняться другая страница. Если все страницы заполнены, то происходит увеличение массива страниц (согласно мульипликативной схеме описанной в задаче Vector). При этом уже заполненные страницы не пересоздаются и не копируются, достаточно лишь перебросить указатели на них в новый буфер. Это позволяет получать быстрый доступ к каждому элементу по индексу (достаточно вычислить номер страницы и позицию элемента в ней), а так как данные хранятся только внутри страниц (которые не удаляются и не перевыделяются), то все ссылки и указатели остаются валидными.

Определите шаблон `Deque`, с размером страницы в 100 элементов и в котором есть:

* Конструктор по умолчанию.
* Конструктор копирования.
* Оператор присваивания.
* Деструктор.
* метод `Swap(other)` - обменивает содержимое с другим массивом (`other` имеет тип `Deque`)
* Константный и неконстантный оператор доступа по индексу []. Неконстантный должен позволять изменять полученный элемент (`a[1] = 5`);
* метод `Size()`, возвращающий число элементов в деке.
* метод `PushBack(value)` - добавляет элемент value в конец массива
* метод `PopBack()` - удаляет последний элемент
* методы `PushFront` и `PopFront`.
* метод `Clear()` - устанавливает размер в 0, деаллокации выделенной памяти при этом НЕ происходит

**Замечания.** 

1) В этой задаче запрещается использование стандартной библиотеки C++. Если нужны какие-либо служебные классы или функции, реализуйте их самостоятельно.

2) Проверка устроена таким образом, что требует от вас жесткого следования принятым (выше) сигнатурам и именованиям сущностей. Если вы реализовали требуемый функционал не полностью или интерфейс отличается от заявленного, в ответ вы получите ошибку компиляции

3) В тесты включены проверки функциональности (методы работают так как требует условие), проверка эффективности реализации (что значит эффективно описано выше), проверка корректности работы с памятью (утечки памяти, обращения к памяти не принадлежащей процессу будут приводить к провалу)

4) Вам будет значительно проще реализовать и отладить решение, если вы отдельно реализуете класс кольцевого буффера, страницы и деки как композицию первых двух.
